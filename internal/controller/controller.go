package controller

import (
	"log"
	"math"
	"time"

	"github.com/deseteral/resistere/internal/configuration"
	"github.com/deseteral/resistere/internal/evse"
	"github.com/deseteral/resistere/internal/metrics"
	"github.com/deseteral/resistere/internal/pv"
	"github.com/deseteral/resistere/internal/utils"
	"github.com/deseteral/resistere/internal/vehicle"
)

type Controller struct {
	Vehicles []vehicle.Vehicle
	Mode     Mode

	updateInterval    time.Duration
	inverter          pv.Inverter
	vehicleController vehicle.Controller
	evse              evse.Evse
	metricsRegistry   *metrics.Registry
}

func (c *Controller) StartBackgroundTask() {
	log.Printf("Starting controller with %v interval.\n", c.updateInterval)

	// TODO: Perform first tick immediately, before entering ticker loop.
	//       Make sure the http server is up, as this might block the thread.
	// c.tick()

	// TODO: Currently every tick starts at set interval. This is not correct behaviour.
	//       What should actually happen is each new tick should start at X second interval after the previous one ended
	//       and not when it started.
	//       If processing tick is longer then the interval, then the next tick will start immediately.
	ticker := time.NewTicker(c.updateInterval)
	go func() {
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				c.tick()
			}
		}
	}()
}

func (c *Controller) tick() {
	// The controller should only perform actions when the device is set to automatic mode.
	// It must not interfere with charging process when manual mode is set.
	if c.Mode == ModeManual {
		return
	}

	log.Println("Entering controller tick.")

	metricsFrame := metrics.Frame{}
	metricsFrame.Timestamp = time.Now()

	// Save which car is charging and what's its current set amps.
	// If controller cannot communicate with any car (because none is in range, there was a communication error, etc.)
	// it should stop further processing.
	// TODO: Perhaps this could be running in parallel.
	var selectedVehicle *vehicle.Vehicle = nil
	var currentChargingAmps int
	var selectedVehicleMetricsFrame *metrics.VehicleFrame
	var vehicleMetrics []metrics.VehicleFrame

	for _, v := range c.Vehicles {
		vehicleMetricsFrame := metrics.NewVehicleMetricsFrame()
		vehicleMetricsFrame.Name = v.Name

		chargingAmps, err := c.vehicleController.GetChargingAmps(&v)

		if err != nil {
			log.Printf("Could not communicate with the car %s: %v.\n", v.Name, err)

			// Don't break the loop here. This car is probably just out of range. We should process next configured car.
			continue
		}

		vehicleMetricsFrame.IsInRange = true

		if chargingAmps > 0 {
			selectedVehicle = &v
			currentChargingAmps = chargingAmps
			selectedVehicleMetricsFrame = &vehicleMetricsFrame

			selectedVehicleMetricsFrame.SetChargingAmps = chargingAmps
		} else {
			log.Printf("Car %s is in-range but not charging.\n", v.Name)

		}
	}
	metricsFrame.VehicleFrames = vehicleMetrics

	if selectedVehicle == nil {
		log.Println("No vehicle is charging. Exiting controller tick.")
		c.metricsRegistry.LatestFrame = metricsFrame
		return
	}

	log.Printf("Selected vehicle %s with %dA set.\n", selectedVehicle.Name, currentChargingAmps)

	// Get energy surplus (kW) from inverter.
	inverterState, err := c.inverter.ReadEnergySurplus()
	if err != nil {
		log.Printf("Could not read energy surplus from inverter: %v. Exiting controller tick.\n", err)
		return
	}

	metricsFrame.PowerProductionWatts = inverterState.PowerProduction * 1000
	metricsFrame.PowerConsumptionWatts = inverterState.PowerConsumption * 1000

	energySurplus := inverterState.PowerProduction - inverterState.PowerConsumption

	// Convert from kilowatts to watts.
	energySurplus = math.Floor(energySurplus * 1000)

	log.Printf("Current energy surplus: %dW.\n", int(energySurplus))

	// Add safety margin of 1kW to surplus, to ensure that we don't charge with energy from the grid.
	// TODO: Safety margin should be configurable.
	energySurplus -= 1000

	// Calculate by how much we should change the charging speed.
	//   3 * V * A = W
	//   A = W / (V * 3)
	//   ▲   ▲    ▲   ▲
	//   │   │    │   └──EVSE is using three-phases to charge.
	//   │   │    └──the electric potential of energy grid, in volts.
	//   │   └──the energy surplus (the difference between power generated by PV and total power used), in watts.
	//   └──the amount by which we can increase or decrease charging current, in amps.
	gridVoltage := 230 // TODO: This is always 230V or so in Europe, but it should be configurable.
	deltaAmps := int(energySurplus) / (gridVoltage * 3)

	log.Printf("Calculated delta amps: %dA.\n", deltaAmps)

	// Calculate charging amps the car should use.
	// It has to be between 5A and 16A (min and max charging amps for 3kW and 11kW).
	nextAmps := currentChargingAmps + deltaAmps
	nextAmps = utils.Clamp(nextAmps, 5, 16)

	// Send next charging amps value to the car.
	log.Printf("Setting charging amps to %dA for car %s.\n", nextAmps, selectedVehicle.Name)

	err = c.vehicleController.SetChargingAmps(selectedVehicle, nextAmps)
	if err != nil {
		log.Printf("Could not set charging amps for car %s: %v. Exiting controller tick.\n", selectedVehicle.Name, err)
		return
	} else {
		selectedVehicleMetricsFrame.SetChargingAmps = nextAmps
	}

	c.metricsRegistry.LatestFrame = metricsFrame

	log.Println("Controlled tick finished successfully.")
}

// TODO: When set to manual it should return back to automatic after certain time (10 minutes?) of not charging.
//
//	This is important as "automatic" is the default, and leaving the controller running in manual
//	could lead to accidental grid usage.
func (c *Controller) ChangeMode(mode Mode) {
	log.Printf("Setting controller mode to %v.\n", modeName[mode])
	c.Mode = mode
}

func NewController(
	inverter pv.Inverter,
	vehicleController vehicle.Controller,
	config *configuration.Config,
	metricsRegistry *metrics.Registry,
) Controller {
	var v []vehicle.Vehicle
	for _, c := range config.Vehicles.Cars {
		v = append(v, vehicle.Vehicle{Name: c.Name, Vin: c.Vin})
	}

	return Controller{
		Vehicles: v,
		Mode:     ModeManual,

		updateInterval:    time.Duration(config.Controller.CycleIntervalSeconds) * time.Second,
		inverter:          inverter,
		vehicleController: vehicleController,
		metricsRegistry:   metricsRegistry,
	}
}
