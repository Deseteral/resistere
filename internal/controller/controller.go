package controller

import (
	"github.com/deseteral/resistere/internal/configuration"
	"github.com/deseteral/resistere/internal/evse"
	"github.com/deseteral/resistere/internal/pv"
	"github.com/deseteral/resistere/internal/vehicle"
	"log"
	"math"
	"time"
)

type Controller struct {
	Vehicles []vehicle.Vehicle

	mode              Mode
	updateInterval    time.Duration
	inverter          pv.Inverter
	vehicleController vehicle.Controller
	evse              evse.Evse
}

type Mode int

const (
	ModePVAutomatic Mode = iota
	ModeManual
)

var modeName = map[Mode]string{
	ModePVAutomatic: "PV Automatic",
	ModeManual:      "Manual",
}

func (c *Controller) StartBackgroundTask() {
	log.Printf("Starting controller with %v interval.\n", c.updateInterval)

	// TODO: Currently every tick starts at set interval. This is not correct behaviour.
	//       What should actually happen is each new tick should start at X second interval after the previous one ended
	//       and not when it started.
	//       If processing tick is longer then the interval, then the next tick will start immediately.
	ticker := time.NewTicker(c.updateInterval)
	go func() {
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				c.tick()
			}
		}
	}()
}

func (c *Controller) tick() {
	// The controller should only perform actions when the device is set to automatic mode.
	// It must not interfere with charging process when manual mode is set.
	if c.mode == ModeManual {
		return
	}

	log.Println("Entering controller tick.")

	// Save which car is charging and what's its current set amps.
	// If controller cannot communicate with any car (because none is in range, there was a communication error, etc.)
	// it should stop further processing.
	var selectedVehicle *vehicle.Vehicle = nil
	var currentChargingAmps int
	for _, v := range c.Vehicles {
		chargingAmps, err := c.vehicleController.GetChargingAmps(&v)
		if err != nil {
			log.Printf("Could not communicate with the car %s: %v.\n", v.Name, err)
			// Don't break the loop here. This car is probably just out of range. We should process next configured car.
		}

		if chargingAmps > 0 {
			selectedVehicle = &v
			currentChargingAmps = chargingAmps
			// We only operate on one car, so if this one is in range and charging we can skip checking other cars.
			break
		}
	}

	if selectedVehicle == nil {
		log.Println("No vehicle is charging. Exiting controller tick.")
		return
	}

	log.Printf("Selected vehicle %s with %dA set.\n", selectedVehicle.Name, currentChargingAmps)

	// Get energy surplus (kW) from inverter.
	inverterState, err := c.inverter.ReadEnergySurplus()
	if err != nil {
		log.Printf("Could not read energy surplus from inverter: %v. Exiting controller tick.\n", err)
		return
	}
	energySurplus := inverterState.PowerProduction - inverterState.PowerConsumption

	// Add safety margin of 1kW to surplus, to ensure that we don't charge with energy from the grid.
	energySurplus -= 1

	// Convert from kilowatts to watts.
	energySurplus = math.Floor(energySurplus * 1000)

	log.Printf("Current energy surplus: %dW.\n", int(energySurplus))

	// Calculate by how much we should change the charging speed.
	//   3 * V * A = W
	//   A = W / (V * 3)
	//   ^   ^    ^   ^--EVSE is using three-phases to charge.
	//   |   |    |__the electric potential of energy grid, in volts.
	//   |   |__the energy surplus (the difference between power generated by PV and total power used), in watts.
	//   |__the amount by which we can increase or decrease charging current, in amps.
	gridVoltage := 230 // TODO: This is always 230V or so in Europe, but it should be configurable.
	deltaAmps := int(energySurplus) / (gridVoltage * 3)

	log.Printf("Calculated delta amps: %dA.\n", deltaAmps)

	// Calculate the charging amps the car should use.
	// It has to be between 5A and 16A (min and max charging amps for 3kW and 11kW).
	nextAmps := currentChargingAmps + deltaAmps
	if nextAmps < 5 {
		nextAmps = 5
	} else if nextAmps > 16 {
		nextAmps = 16
	}

	// Send next charging amps value to the car.
	log.Printf("Setting charging amps to %dA for car %s.\n", nextAmps, selectedVehicle.Name)

	err = c.vehicleController.SetChargingAmps(selectedVehicle, nextAmps)
	if err != nil {
		log.Printf("Could not set charging amps for car %s: %v. Exiting controller tick.\n", selectedVehicle.Name, err)
		return
	}

	log.Println("Controlled tick finished successfully.")
}

func (c *Controller) ChangeMode(mode Mode) {
	log.Printf("Setting controller mode to %v.\n", modeName[mode])
	c.mode = mode
}

func NewController(
	inverter pv.Inverter,
	vehicleController vehicle.Controller,
	evse evse.Evse,
	config *configuration.Config,
) Controller {
	var v []vehicle.Vehicle
	for _, c := range config.Vehicles.Cars {
		v = append(v, vehicle.Vehicle{Name: c.Name, Vin: c.Vin})
	}

	return Controller{
		Vehicles: v,

		mode:              ModeManual,
		updateInterval:    time.Duration(config.Controller.CycleIntervalSeconds) * time.Second,
		inverter:          inverter,
		vehicleController: vehicleController,
		evse:              evse,
	}
}
