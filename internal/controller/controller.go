package controller

import (
	"log"
	"math"
	"time"

	"github.com/deseteral/resistere/internal/configuration"
	"github.com/deseteral/resistere/internal/metrics"
	"github.com/deseteral/resistere/internal/pv"
	"github.com/deseteral/resistere/internal/utils"
	"github.com/deseteral/resistere/internal/vehicle"
)

type Controller struct {
	Vehicles []vehicle.Vehicle
	Mode     Mode

	updateInterval    time.Duration
	inverter          pv.Inverter
	vehicleController vehicle.Controller
	metricsRegistry   *metrics.Registry
	config            *configuration.Config
}

func (c *Controller) StartBackgroundTask() {
	log.Printf("Starting controller with %v interval.\n", c.updateInterval)

	ticker := time.NewTicker(c.updateInterval)
	go func() {
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				c.tick()
			}
		}
	}()
}

func (c *Controller) tick() {
	log.Println("Entering controller tick.")

	// Setup metrics frame for current processing tick.
	// Make sure that all exit points of the tick commit the new metrics frame as the latest one.
	metricsFrame := metrics.NewMetricsFrame()
	defer func() { c.metricsRegistry.LatestFrame = metricsFrame }()

	// Read the current inverter state.
	//
	// This is done before checking the controller mode, because we want to have current production
	// and consimption for metrics regardles of the controller mode and charging state.
	//
	// Handling the returned error is done further down this flow.
	// This is because even if we could not read data from inverter
	inverterState, inverterStateErr := c.inverter.ReadInverterState()

	if inverterStateErr == nil {
		metricsFrame.PowerProductionWatts = inverterState.PowerProduction
		metricsFrame.PowerConsumptionWatts = inverterState.PowerConsumption
	}

	// The controller should only perform actions when the device is set to automatic mode.
	// It must not interfere with charging process when manual mode is set.
	if c.Mode == ModeManual {
		log.Println("Exiting controller tick because it's in manual mode.")
		return
	}

	// Check for all known vehicles and see which one (if any) is charging.
	// Save which car is charging and what's its current set amps.
	var selectedVehicle *vehicle.Vehicle
	var selectedVehicleChargingAmps int

	for _, v := range c.Vehicles {
		vehicleMetricsFrame := metrics.NewMetricsVehicleFrame(v.Name)

		chargingState, err := c.vehicleController.GetChargingState(&v)
		if err != nil {
			log.Printf("Could not communicate with the car %s: %v.\n", v.Name, err)

			// Don't break the loop here.
			// This car is probably just out of range. We should process next configured car.
			continue
		}

		if chargingState.Amps > 0 {
			selectedVehicle = &v
			selectedVehicleChargingAmps = chargingState.Amps

			vehicleMetricsFrame.ChargingPowerWatts = chargingState.Power * 1000.0
		} else {
			log.Printf("Car %s is in-range but not charging.\n", v.Name)
		}

		metricsFrame.VehicleFrames = append(metricsFrame.VehicleFrames, vehicleMetricsFrame)
	}

	// If controller could not communicate with any car (because none is in range, there was a communication error, etc.)
	// it should stop further processing.
	if selectedVehicle == nil {
		log.Println("No vehicle is charging. Exiting controller tick.")
		return
	}
	log.Printf("Selected vehicle %s with %dA set.\n", selectedVehicle.Name, selectedVehicleChargingAmps)

	// If controller could not get energy surplus data from intverter it should stop further processing.
	if inverterStateErr != nil {
		log.Printf("Could not read energy surplus from inverter: %v. Exiting controller tick.\n", inverterStateErr)
		return
	}

	// Calculate energy surplus from inverter data.
	energySurplus := math.Floor(inverterState.PowerProduction - inverterState.PowerConsumption)

	log.Printf("Current energy surplus: %d W.\n", int(energySurplus))

	// Add safety margin to surplus, to ensure that we don't charge with energy from the grid.
	energySurplus -= float64(c.config.Controller.SafetyMarginWatts)

	// Calculate by how much we should change the charging speed.
	//   3 * V * A = W
	//   A = W / (V * 3)
	//   ▲   ▲    ▲   ▲
	//   │   │    │   └──EVSE is using three-phases to charge.
	//   │   │    └──the electric potential of energy grid, in volts.
	//   │   └──the energy surplus (the difference between power generated by PV and total power used), in watts.
	//   └──the amount by which we can increase or decrease charging current, in amps.

	deltaAmps := int(energySurplus) / (c.config.Controller.GridVoltage * 3)

	log.Printf("Calculated delta amps: %dA.\n", deltaAmps)

	// Calculate charging amps the car should use.
	// It has to be between 5A and 16A (min and max charging amps for 3kW and 11kW).
	nextAmps := utils.Clamp(selectedVehicleChargingAmps+deltaAmps, 5, 16)

	// Send next charging amps value to the car.
	log.Printf("Setting charging amps to %d A for car %s.\n", nextAmps, selectedVehicle.Name)

	err := c.vehicleController.SetChargingAmps(selectedVehicle, nextAmps)
	if err != nil {
		log.Printf("Could not set charging amps for car %s: %v. Exiting controller tick.\n", selectedVehicle.Name, err)
		return
	}

	log.Println("Controlled tick finished successfully.")
}

func (c *Controller) ChangeMode(mode Mode) {
	log.Printf("Setting controller mode to %v.\n", modeName[mode])
	c.Mode = mode
}

func NewController(
	inverter pv.Inverter,
	vehicleController vehicle.Controller,
	config *configuration.Config,
	metricsRegistry *metrics.Registry,
) Controller {
	var v []vehicle.Vehicle
	for _, c := range config.Vehicles.Cars {
		v = append(v, vehicle.Vehicle{Name: c.Name, Vin: c.Vin})
	}

	return Controller{
		Vehicles: v,
		Mode:     ModeManual,

		updateInterval:    time.Duration(config.Controller.CycleIntervalSeconds) * time.Second,
		inverter:          inverter,
		vehicleController: vehicleController,
		metricsRegistry:   metricsRegistry,
		config:            config,
	}
}
